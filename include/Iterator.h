//
// Created by giacomo on 15/10/20.
//

#ifndef FUZZYSTRINGMATCHING2_ITERATOR_H
#define FUZZYSTRINGMATCHING2_ITERATOR_H

#include <unordered_map>

struct pair_hash
{
    template <class T1, class T2>
    std::size_t operator() (const std::pair<T1, T2> &pair) const
    {
        return std::hash<T1>()(pair.first) ^ std::hash<T2>()(pair.second);
    }
};

/**
 * This data structure implements an iterator over a current matrix, representing the i-th closure of the graph
 */
struct iterator {
    double summation;
    std::unordered_map<std::pair<std::string, std::string>, double, pair_hash>& embedding;
    std::unordered_map<std::pair<std::string, std::string>, double, pair_hash> current_step;
    size_t len;
    double lambda_pow, lambda;

    /**
     * Initialization
     * @param E             Graph's embedding map, passed by reference
     * @param l             Transitive closure decay factor
     * @param len           Current length of the paths generated by the transitive closure
     */
    iterator(std::unordered_map<std::pair<std::string, std::string>, double, pair_hash>& E, double l, size_t len = 1);

    /**
     * Builds up the embedding for the left-right/pathLen
     * @param left      Label associated to the current left node
     * @param right     Label associated to the current right node
     * @param value     Value associated to the path
     */
    void accept(const std::string& left, const std::string& right, double value);

    /**
     * Finalizes the map by dividing for the possible elements associated to the path
     */
    void nextIteration();

    /**
     * Finalizes the embedding generator
     *
     * @param weight        Weight associated to the graph
     */
    void finalize(double weight);
};


#endif //FUZZYSTRINGMATCHING2_ITERATOR_H
