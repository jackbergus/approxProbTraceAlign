/*
 * OnlyTransitiveEdgesCost.h
 * This file is part of ProbabilisticTraceAlignment
 *
 * Copyright (C) 2020 - Giacomo Bergami
 *
 * ProbabilisticTraceAlignment is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * ProbabilisticTraceAlignment is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProbabilisticTraceAlignment. If not, see <http://www.gnu.org/licenses/>.
 */


//
// Created by giacomo on 15/10/20.
//

#ifndef FUZZYSTRINGMATCHING2_ONLYTRANSITIVEEDGESCOST_H
#define FUZZYSTRINGMATCHING2_ONLYTRANSITIVEEDGESCOST_H

#include <unordered_map>
#include <utils/pair_hash.h>
#include "LabelledPathVisitingStrategy.h"
#include <chrono>
using namespace std::chrono;
//#define NEW_DEFINITION

/**
 * This data structure implements an iterator over a current matrix, representing the i-th closure of the graph
 */
template <bool use_new_definition = true>
struct OnlyTransitiveEdgesCost : public LabelledPathVisitingStrategy {
//#ifndef NEW_DEFINITION
    double edge_summation = 0.0;
    std::string varepsilon;
//#endif
    std::unordered_map<std::pair<std::string, std::string>, double, pair_hash> currentEdgeStep;

    /**
     * Initialization
     * @param E             Graph's embedding map, passed by reference
     * @param l             Transitive closure decay factor
     * @param len           Current length of the paths generated by the transitive closure
     */
    OnlyTransitiveEdgesCost(const std::string& varepsilon, std::unordered_map<std::pair<std::string, std::string>, double, pair_hash> &E, double ignore_tuning, double l,
                                                     size_t len = 1) : LabelledPathVisitingStrategy{E, l, len}, varepsilon{varepsilon}/*, edge_summation{0.0}*/ {
        /*assert(std::abs(l)<=1.0);
        lambda = l;
        this->len = len;
        lambda_pow = std::pow(lambda, (double)this->len);
        summation = 0;*/
    }
    ~OnlyTransitiveEdgesCost() override {}

    /**
     * Builds up the embedding for the left-right/pathLen
     * @param left      Label associated to the current left node
     * @param right     Label associated to the current right node
     * @param value     Value associated to the path
     */
    virtual void acceptMultiedge(const std::string& left, const std::string& right, double value) override {
        steady_clock::time_point vpTreeTransformedStartQuery = steady_clock::now();
        if ((left != varepsilon) && (right != varepsilon)) {
            if (use_new_definition) {
                auto itE = L_node_frequency.insert(std::make_pair(left, 1));
                if (!itE.second) itE.second+=1;
            } else {
                edge_summation += value;  // Summing up all the probabilities for the current iteration.
            }
            auto it = currentEdgeStep.insert(std::make_pair(std::make_pair(left, right), value));
            if (!it.second) it.first->second += value;
        }
        benchmark_time += duration_cast<std::chrono::nanoseconds>(steady_clock::now() - vpTreeTransformedStartQuery).count()/1000000.0;
    }

    /**
     * Finalizes the map by dividing for the possible elements associated to the path
     */
    virtual void nextEdgeIteration() override {
        steady_clock::time_point vpTreeTransformedStartQuery = steady_clock::now();
        for (auto& it : currentEdgeStep) {
            const std::pair<std::string, std::string>& cp = it.first;
            double normalization;
            if (use_new_definition) {
                normalization = L_node_frequency[cp.first];
            } else {
                normalization = edge_summation;
            }
            double tmp = (it.second / normalization) * lambda_pow;
            auto final = pair_embedding.insert(std::make_pair(cp, tmp)); // try to insert the current value
            if (!final.second) {
                final.first->second += tmp; // If a previous value exist, add this probability to the other one that was previously set up.
            }
        }
        currentEdgeStep.clear();
        len++;
        lambda_pow *= lambda;
        if (use_new_definition) {
            L_node_frequency.clear();
        } else {
            edge_summation = 0;
        }
        benchmark_time += duration_cast<std::chrono::nanoseconds>(steady_clock::now() - vpTreeTransformedStartQuery).count()/1000000.0;
    }

    /**
     * Finalizes the embedding generator
     *
     * @param weight        Weight associated to the graph
     */
    virtual double finalize(double weight) override {
        steady_clock::time_point vpTreeTransformedStartQuery = steady_clock::now();
        double S = 0; // Define a probability distribution over the all components: we need to normalize their values. Summing up all the results
        for (const auto& it : pair_embedding) {
            S += (it.second * it.second);
        }
        if (S <= machine_epsilon)
            S = machine_epsilon;
        ///std::cerr << S << std::endl;
        for (auto& it : pair_embedding) {
            const double normalized_over_current_length_distribution = (it.second / S) ; // Normalization of the component
            const double weight_the_resulting_value_with_the_graph_s_weight = normalized_over_current_length_distribution * weight; // Multiplying by weight, so that if all the elegible criteria are met, the desired probability is returned
            it.second = weight_the_resulting_value_with_the_graph_s_weight;
        }
        benchmark_time += duration_cast<std::chrono::nanoseconds>(steady_clock::now() - vpTreeTransformedStartQuery).count()/1000000.0;
        double cpy = 0.0;
        std::swap(benchmark_time, cpy);
        return cpy;
    }


    void acceptNode(const std::string &node, double value) override {}; // noop
    void nextNodeIteration(double thisNormalizationCost) override {}; // noop

private:
//#ifdef NEW_DEFINITION
    std::unordered_map<std::string, size_t> L_node_frequency;
//#endif
};


#endif //FUZZYSTRINGMATCHING2_ONLYTRANSITIVEEDGESCOST_H
