//
// Created by giacomo on 19/10/20.
//

#ifndef FUZZYSTRINGMATCHING2_LABELLEDPATHVISITINGSTRATEGY_H
#define FUZZYSTRINGMATCHING2_LABELLEDPATHVISITINGSTRATEGY_H

#include <utils/pair_hash.h>
#include <unordered_map>
#include <cmath>

enum PathEmbeddingStrategy {
    ONLY_EDGE_INFORMATION_PROPOSED,
    EDGE_WITH_NODE_INFORMATION_PROPOSED,
    ONLY_EDGE_INFORMATION_PREVIOUS,
    EDGE_WITH_NODE_INFORMATION_PREVIOUS
};

struct LabelledPathVisitingStrategy {
    std::unordered_map<std::pair<std::string, std::string>, double, pair_hash>& pair_embedding;
    size_t len;
    double lambda_pow, lambda;

    /**
     * Initialization
     * @param E             Graph's embedding map, passed by reference
     * @param l             Transitive closure decay factor
     * @param len           Current length of the paths generated by the transitive closure
     */
    LabelledPathVisitingStrategy(std::unordered_map<std::pair<std::string, std::string>, double, pair_hash>& E, double l, size_t len = 1);
    virtual ~LabelledPathVisitingStrategy() {}

    /**
     * Builds up the embedding for the left-right/pathLen
     * @param left      Label associated to the current left node
     * @param right     Label associated to the current right node
     * @param value     Value associated to the path
     */
    virtual void acceptMultiedge(const std::string& left, const std::string& right, double value) = 0;
    virtual void acceptNode(const std::string& node, double value) = 0;


    /**
     * Finalizes the map by dividing for the possible elements associated to the path
     */
    virtual void nextEdgeIteration() = 0;
    virtual void nextNodeIteration(double thisNormalizationCost) = 0;

    /**
     * Finalizes the embedding generator
     *
     * @param weight        Weight associated to the graph
     */
    virtual void finalize(double weight) = 0;
};

#include <random>
#include <Eigen/Sparse>

template <typename T> std::enable_if_t<std::is_base_of_v<LabelledPathVisitingStrategy, T>, void> matrix_iterator(Eigen::SparseMatrix<double, Eigen::RowMajor>& A, std::unordered_map<size_t, std::string>& map, T& obj) {
    for (int k=0; k < A.outerSize(); ++k)
    {
        for (Eigen::SparseMatrix<double, Eigen::RowMajor>::InnerIterator it(A,k); it; ++it)
        {
            size_t i = it.row(), j = it.col();
            double v = it.value();
            obj.acceptMultiedge(map[i], map[j], v);
        }
    }
}


#endif //FUZZYSTRINGMATCHING2_LABELLEDPATHVISITINGSTRATEGY_H
